PROCEDURES - É uma espécie de programa que irá executar certa ação recebendo parâmetros.
  .Pontos de um Stored Procedure:
  	..O nome da Stored Procedure deve ter apenas letras, números, $ e _.
  	..Tamanho máximo de 64 caracteres.
  	..Deve ser nome único.
  	..É case senstive.
  	
  .Criar uma PROCEDURE:
  	Botão direito em Stored Procedures -> Create Stored Procedures -> Preencher com as operações.
  	
  	Ex: CREATE PROCEDURE `show_number_alias` ()
	    BEGIN
	    select (1+0)-5 as RESULTADO;
	    END
	    
	..Podemos usar funções na procedure:
		CREATE DEFINER=`root`@`localhost` PROCEDURE `sp_with_functions`()
		BEGIN
		select concat('Alô mundo!!!','...',(8+13)-5) as ITENS_COMBINADOS;
		END
		
	..Podemos utilizar comentários nas procedures:
		Comentário pode ser uma única linha, utilizando o -- ou utilizando /* */
		
		Ex:CREATE DEFINER=`root`@`localhost` PROCEDURE `sp_with_comment`()
		BEGIN
		/* Vamos exibir itens combinados 
		entre textos e números */
		-- Usando a função CONCAT
		select concat('Alô mundo!!!', 33+(10-20), ' Tchau!!!');
		END
  	
  .Para chamar uma Stored Procedure, utilizamos a função call:
  	call hello_world;
  	
  .Para alterar ou excluir uma Stored Procedure: 
  	Botão direito na Procedure desejada -> Alter/Drop Stored Procedure;
  	
  .Podemos fazer o create, alter e drop por linha de comando:
  	..Create - 
  		USE `vendas_sucos`;
  		DROP procedure IF EXISTS `hello_world_2`;

		DELIMITER $$
		USE `vendas_sucos`$$
		CREATE PROCEDURE `hello_world_2` ()
		BEGIN
		select 'Alô mundo!!!' as RESULTADO;
		END$$
		
		DELIMITER ;

	..Alter - 
		USE `vendas_sucos`;
		DROP procedure IF EXISTS `hello_world_2`;

		DELIMITER $$
		USE `vendas_sucos`$$
		CREATE PROCEDURE `hello_world_2`()
		BEGIN
		select 'Alô mundo, tudo bem??' as RESULTADO;
		END$$

		DELIMITER ;
		
	..Drop - 
		USE `vendas_sucos`;
  		DROP procedure IF EXISTS `hello_world_2`;
  	
  	Obs: O delimiter serve para modificar a separação de linha, para que o workbench não confunda o ; da criação da procedure com os ; das linhas de comandos do procedure.
  	
  .Criando Variáveis:
  	..Caracteristicas de uma Variável:
  		...Datatype é obrigatório.
  		...Default é opcional.
  		...Nome de variável pode ter apenas letras, números, $ e _.
  		...Deve ser único dentro da Stored Procedure.
  		...É case sensitive.
  		...Tamanho máximo 255 caracteres.
  		...Se não houver valor default, o valor da variável será null.
  		...A linha de declaração deve terminar com ponto e vírgula.
  		
  		Obs: Variáveis são boas na criação de procedures pois permite criar um dinamismo no programa.
  		
  	..Tipos de Variáveis:
  		...Varchar(n) - Caracteres textos com tamanho máximo de n caracteres.
  		...Integer - Variável do tipo inteiro.
  		...Decimal(p,s) - Variável decimal com p dígitos e s pontos decimais.
  		...Date - Para guardar data.
  		...Timestamp - Para guardar data e hora.
  	
  	..Declarando uma Variável:
  		declare nome_variavel datatype_variavel default valor_default;
  		
  		declare texto char(20) default 'Olá mundo!!!';
  		declare ts datetime default localtimestamp();
  		
  		Obs: Podemos declarar mais de uma variável por comando - 
  			declare data_1, data_2 date default '2020-03-11';
  			
  		Obs: Podemos dar valores a variáveis durante a procedure através do set - 
  			declare texto varchar(30) default 'Texto inicial';
  			set texto = 'Texto modificado';
  			
  		Ex: CREATE PROCEDURE `sp_Exerc01` ()
  		    BEGIN
  		      declare Cliente varchar(10);
  		      declare Idade integer;
  		      declare DataNascimento date;
  		      declare Custo decimal(4,2);
  		      set Cliente = 'João';
  		      set Idade = 10;
  		      set DataNascimento = '2007-01-10';
  		      set Custo = 10.23;
  		      select Cliente, Idade, DataNascimento, Custo;
  		    END
  		    
  		Obs: Para apagar uma procedure por linha de comando - 
  			DROP procedure IF EXISTS `teste`;
  			
  .Inserindo valores com VARIÁVEIS atrabés de STORED PROCEDURES:
  	DECLARE vCodigo varchar(50) DEFAULT '3000001';
  	DECLARE vNome varchar(50) DEFAULT 'Sabor do Mar 700 ml - Manga';
  	DECLARE vSabor varchar(50) DEFAULT 'Manga';
  	DECLARE vTamanho varchar(50) DEFAULT '700 ml';
  	DECLARE vEmbalagem varchar(50) DEFAULT 'Garrafa';
  	DECLARE vPreco DECIMAL(10,2) DEFAULT 9.25;
  	INSERT INTO tabela_de_produtos
  	(CODIGO_DO_PRODUTO,NOME_DO_PRODUTO,SABOR,TAMANHO,EMBALAGEM,PRECO_DE_LISTA)
     	VALUES (
     	vCodigo,
     	vNome,
     	vSabor,
     	vTamanho,
     	vEmbalagem,
     	vPreco);
     	
     	Exércicio: Crie uma Stored procedure que atualize a idade dos clientes - 
     		update tabela_de_clientes set IDADE = TIMESTAMPDIFF(YEAR, data_de_nascimento, CURDATE());
     		
  .Utilizando PARÂMETROS EM UMA STORED PROCEDURE:
  	--
  	CREATE PROCEDURE `inclui_novo_produto_parametro` (vCodigo varchar(50), vNome varchar(50), vSabor varchar(50), vTamanho varchar(50), vEmbalagem varchar(50), vPreco DECIMAL(10,2))
	BEGIN
	  INSERT INTO tabela_de_produtos
	  (CODIGO_DO_PRODUTO,NOME_DO_PRODUTO,SABOR,TAMANHO,EMBALAGEM,PRECO_DE_LISTA)
	  VALUES (
	  vCodigo,
	  vNome,
	  vSabor,
	  vTamanho,
	  vEmbalagem,
	  vPreco);
	END
	
	call inclui_novo_produto_parametro('4000132','Sabor da Montanha 700 ml - Uva','Uva','700 ml','Garrafa', 9.30);
	--
	
	--
	
	CREATE DEFINER=`root`@`localhost` PROCEDURE `Reajuste_Comissao`(vComissao float)
	BEGIN
	update tabela_de_vendedores set PERCENTUAL_COMISSAO = vComissao; / UPDATE tabela_de_vendedores SET percentual_comissao = percentual_comissao * (1 + vPercent);
	select * from tabela_de_vendedores;
	END
	
	call Reajuste_Comissao(0.90);
	--
	
	Obs: Aos invés de declararmos as variáveis, colocamos elas no local do parâmetro, entre parenteses depois do nome da stored procedure.
	
  .Controle de erros com mensagens:
  	..Utilizando mensagem simples:
  		CREATE PROCEDURE `inclui_novo_produto_parametro`(vCodigo varchar(50), vNome varchar(50), vSabor varchar(50), vTamanho varchar(50), vEmbalagem varchar(50), vPreco DECIMAL(10,2))
  		BEGIN
  		declare mensagem varchar(40);
  		INSERT INTO tabela_de_produtos
  		(CODIGO_DO_PRODUTO,NOME_DO_PRODUTO,SABOR,TAMANHO,EMBALAGEM,PRECO_DE_LISTA)
  	   	VALUES (
  	  	vCodigo,
  	  	vNome,
  	  	vSabor,
  	   	vTamanho,
  	   	vEmbalagem,
		Preco);
  		set mensagem = 'Produto inserido com sucesso!';
  		select mensagem as Mensagem;
  		END

	..Para o controle de erro, utilizamos o declare exit handler for codigo_do_erro, que traduzindo, caso ocorra o erro especificado, ele irá sair do programa e executar os comandos entre o BEGIN e END (No nosso caso será exibir a mensagem de erro) - 
		CREATE PROCEDURE `inclui_novo_produto_parametro`(vCodigo varchar(50), vNome varchar(50), vSabor varchar(50), vTamanho varchar(50), vEmbalagem varchar(50), vPreco DECIMAL(10,2))
		BEGIN
		declare mensagem varchar(40);
		declare exit handler for 1062
		BEGIN
		  set mensagem = 'Cógido de produto já existente!';
		  select mensagem as Mensagem;
		END;
		INSERT INTO tabela_de_produtos
		(CODIGO_DO_PRODUTO,NOME_DO_PRODUTO,SABOR,TAMANHO,EMBALAGEM,PRECO_DE_LISTA)
		     VALUES (vCodigo,
		     vNome,
		     vSabor,
		     vTamanho,
		     vEmbalagem,
		     vPreco);
		set mensagem = 'Produto inserido com sucesso!';
		select mensagem as Mensagem;
		END
	
	Obs: O controle de erro precisa estar antes do INSERT, pois fica guardado o a declaração para caso ocorra o erro, então ele para o comando, por exemplo de INSERT, e executa o controle de erro.
	
	..Utilizando o SELECT para atribuir valor a variável:
		CREATE PROCEDURE `acha_sabor_produto` (vProduto varchar(50))
		BEGIN
		declare vSabor varchar(50);
		select SABOR into vSabor from tabela_de_produtos where CODIGO_DO_PRODUTO = vProduto;
		select vSabor;
		END

		Obs: É necessário usar o INTO para transformar o campo em uma variável, para podermos imprimir a variável com a informação correta.
		
		Exercício: Crie uma variável chamada NUMNOTAS e atribua a ela o número de notas fiscais do dia 01/01/2017. Mostre na saída do script o valor da variável. (Chame esta Stored Procedure de Quantidade_Notas) - 
			CREATE PROCEDURE `Quantidade_Notas`()
			BEGIN
			declare NUMNOTAS integer;
			select count(*) into NUMNOTAS from notas_fiscais where DATA_VENDA = '2017-01-01' group by DATA_VENDA ;
			select NUMNOTAS as `Qtd de Notas`;
			END
		
  .Fazendo controle de fluxo utilizando IF:
  	IF condição then ... else ... end if
  	
  	CREATE PROCEDURE `cliente_novo_velho`(vCPF varchar(11)) (menores de 2000 = novos, maiores de 2000 = velhos)
  	BEGIN
  	  declare vResultado varchar(20);
  	  declare vDataNascimento date;
  	  select DATA_DE_NASCIMENTO into vDataNascimento from tabela_de_clientes where CPF = vCPF;
  	  if vDataNascimento < '2000-01-01' then 
  	  	set vResultado = 'Cliente novo';
  	  else 
  	  	set vResultado = 'Cliente velho';
	  end if;
	  select vResultado as `Estado cliente`;
	END
	
	Exercício: Crie uma Stored Procedure que, baseado em uma data, contamos o número de notas fiscais. Se houverem mais que 70 notas exibimos a mensagem: ‘Muita nota’. Ou então exibimos a mensagem ‘Pouca nota’. Também exibir o número de notas. Chame esta Stored Procedure de Testa_Numero_Notas - 
		CREATE PROCEDURE `Testa_Numero_Notas`(vData date)
		BEGIN
		  declare vQuantidade integer;
		  declare vResultado varchar(50);
		  select count(*) into vQuantidade from notas_fiscais where DATA_VENDA = vData group by DATA_VENDA;
		  if vQuantidade > 70 then
			set vResultado = 'Muita nota';
		  else
		  	set vResultado = 'Pouca nota';
		  end if;
		  select vResultado as `Situação nota`, vQuantidade as Quantidade;
		END
	
	..Utilizando o ELSEIF:
		CREATE PROCEDURE `ACHA_STATUS_PRECO`(vProduto varchar(30))
		BEGIN
		  declare vPreco float;
		  declare vResultado varchar(50);
		  select PRECO_DE_LISTA into vPreco from tabela_de_produtos where CODIGO_DO_PRODUTO = vProduto;
		  if vPreco >= 12.00 then
			set vResultado = 'Produto caro';
		  elseif vPreco < 12.00 and vPreco >= 7.00 then
			set vResultado = 'Produto em conta';
		  else 
			set vResultado = 'Produto barato';
		  end if;
		  select vResultado as `Status do produto`;
		END
		
	Exercício: Construa uma Stored Procedure chamada Comparativo_Vendas que compara as vendas em duas datas (Estas duas datas serão parâmetros da SP). Se a variação percentual destas vendas for maior que 10% a resposta deve ser ‘Verde’. Se for entre -10% e 10% deve retornar ‘Amarela1. Se o retorno form menor que -10% deve retornar ‘Vermelho’ - 
		CREATE DEFINER=`root`@`localhost` PROCEDURE `Comparativo_Vendas`(vDataInicial date, vDataFinal date)
		BEGIN
		  declare vResultado varchar(50);
		  declare vFaturamentoInicial float;
		  declare vFaturamentoFinal float;
		  declare vVariacao float;
		  SELECT SUM(B.QUANTIDADE * B.PRECO) into vFaturamentoInicial FROM --calculo do faturamento inicial
		  notas_fiscais A INNER JOIN itens_notas_fiscais B
		  ON A.NUMERO = B.NUMERO
		  WHERE A.DATA_VENDA = vDataInicial; --calculo do faturamento inicial
		  SELECT SUM(B.QUANTIDADE * B.PRECO) into vFaturamentoFinal FROM 
		  notas_fiscais A INNER JOIN itens_notas_fiscais B
		  ON A.NUMERO = B.NUMERO
		  WHERE A.DATA_VENDA = vDataFinal;
		  set vVariacao = (((vFaturamentoFinal / vFaturamentoInicial)-1)*100);
		  if vVariacao > 10 then
			set vResultado = 'Verde';
		  elseif vVariacao <= 10 and vVariacao >= -10 then
			set vResultado = 'Amarela';
		  else 
			set vResultado = 'Vermelho';
		  end if;
  		  select vResultado as `Situação faturamento`, vVariacao as `Variação`;
		END
		
  .Utilizando o CASE:
  	case seletor when seletor_valor_! then acao_1 when seletor_valor_2 then acao_2 ... else acao_n end case;
  	
  	CREATE DEFINER=`root`@`localhost` PROCEDURE `acha_tipo_sabor`(vProduto varchar(15))
	BEGIN
	  declare vSabor varchar(20);
	  select SABOR into vSabor from tabela_de_produtos where CODIGO_DO_PRODUTO = vProduto;
	  case vSabor
	    when 'Lima/Limão' then select vSabor as SABOR, 'Cítrico' as TIPO;
	    when 'Laranja' then select vSabor as SABOR, 'Cítrico' as TIPO;
	    when 'Morango/Limão' then select vSabor as SABOR, 'Cítrico' as TIPO;
	    when 'Uva' then select vSabor as SABOR, 'Neutro' as TIPO;
	    when 'Morango' then select vSabor as SABOR, 'Neutro' as TIPO;
	    else select vSabor as SABOR, 'Ácido' as TIPO;
	  end case;
	END
	
	..Lidando com o erro CASE NOT FOUND sem o else:
		-- (Caso entre em um case existente abre duas janelas, uma do tipo e uma de mensagem NULL)
		CREATE DEFINER=`root`@`localhost` PROCEDURE `acha_tipo_sabor_erro`(vProduto varchar(15))
		BEGIN
		  declare vSabor varchar(20);
		  declare msgError varchar(40);
		  declare continue handler for 1339 set msgError = 'Case incompleto!';
		  select SABOR into vSabor from tabela_de_produtos where CODIGO_DO_PRODUTO = vProduto;
		  case vSabor
		    when 'Lima/Limão' then select vSabor as SABOR, 'Cítrico' as TIPO;
		    when 'Laranja' then select vSabor as SABOR, 'Cítrico' as TIPO;
		    when 'Morango/Limão' then select vSabor as SABOR, 'Cítrico' as TIPO;
		    when 'Uva' then select vSabor as SABOR, 'Neutro' as TIPO;
		    when 'Morango' then select vSabor as SABOR, 'Neutro' as TIPO;
		  end case;
		  select msgError as ERRO;
		END
		--
		CREATE DEFINER=`root`@`localhost` PROCEDURE `acha_tipo_sabor_erro`(vProduto varchar(15))
		BEGIN
		  declare vSabor varchar(20);
		  declare msgError varchar(40);
		  declare continue handler for 1339
		  BEGIN
		    set msgError = 'Case incompleto!';
		    select msgError as ERRO;
		  end;
		  select SABOR into vSabor from tabela_de_produtos where CODIGO_DO_PRODUTO = vProduto;
		  case vSabor (**)
		    when 'Lima/Limão' then select vSabor as SABOR, 'Cítrico' as TIPO;
		    when 'Laranja' then select vSabor as SABOR, 'Cítrico' as TIPO;
		    when 'Morango/Limão' then select vSabor as SABOR, 'Cítrico' as TIPO;
		    when 'Uva' then select vSabor as SABOR, 'Neutro' as TIPO;
		    when 'Morango' then select vSabor as SABOR, 'Neutro' as TIPO;
		  end case;
		END
		-- (Caso entre em um case existente não vai abrir uma janela com mensagem NULL)
		
	..Usando o CASE condicional:
		CREATE DEFINER=`root`@`localhost` PROCEDURE `acha_status_preco_case`(vProduto varchar(30))
		BEGIN
		  declare vPreco float;
		  declare vResultado varchar(50);
		  select PRECO_DE_LISTA into vPreco from tabela_de_produtos where CODIGO_DO_PRODUTO = vProduto;
		  case (*)
		    when vPreco >= 12.0 then set vResultado = 'Produto caro';
		    when vPreco < 12.00 and vPreco >= 7.00 then set vResultado = 'Produto em conta';
		    else set vResultado = 'Produto barato';
		  end case;
		  select vPreco as `Preço`, vResultado as `Status do produto`;
		END
		
		Obs: Usar o case com condicional no lugar do if é um pouco mais eficiente, pois no if/elseif, todos os testes são testados até encontrar a a confição certa ou entrar no else e ai rodar ele roda a operação da condição, enquanto que no case, ele tem previamente definida a operação e ao entrar nos cases, ele vai diretamente pra a opção a ser selecionada.
		
		Obs: No CASE condicional declaramos apenas CASE (*), pois a variável a ser testada já está no when, enquanto que no CASE normal (**), pois iremos testar a variável para os casos do when.
		
		Exercício: 
			CREATE DEFINER=`root`@`localhost` PROCEDURE `Comparativo_Vendas_Case_Cond`(vDataInicial date, vDataFinal date)
			BEGIN
			  declare vFaturamentoInicial float;
			  declare vFaturamentoFinal float;
			  declare vVariacao float;
			  SELECT SUM(B.QUANTIDADE * B.PRECO) into vFaturamentoInicial FROM 
			  notas_fiscais A INNER JOIN itens_notas_fiscais B
			  ON A.NUMERO = B.NUMERO
			  WHERE A.DATA_VENDA = vDataInicial;
			  SELECT SUM(B.QUANTIDADE * B.PRECO) into vFaturamentoFinal FROM 
			  notas_fiscais A INNER JOIN itens_notas_fiscais B
			  ON A.NUMERO = B.NUMERO
			  WHERE A.DATA_VENDA = vDataFinal;
			  set vVariacao = (((vFaturamentoFinal / vFaturamentoInicial)-1)*100);
			  case
			    when vVariacao > 10 then select vVariacao as `Variação`, 'Verde' as Estado;
			    when vVariacao <= 10 and vVariacao >= -10 then select vVariacao as `Variação`, 'Amarelo' as Estado;
			    else select vVariacao as `Variação`, 'Vermelho' as Estado;
			  end case;
			END
  
  .Controle de fluxo com WHILE:
  	while condicao do operacao; end while;
  	
  	CREATE DEFINER=`root`@`localhost` PROCEDURE `looping_while`(vNumeroInicial int, vNumeroFinal int)
	BEGIN
	  declare vContador int;
	  delete from tab_looping;
	  set vContador = vNumeroInicial;
	  while vContador <= vNumeroFinal do
	    insert into tab_looping (ID) values (vContador);
	    set vContador = vContador + 1;
	  end while;
	  select * from tab_looping;
	END
	
	Exercício: 
		-- Imprime a quantidade total de notas, para imprimir diariamente basta colocar 'select count(*) from notas_fiscais where DATA_VENDA = vDataAtual;' dentro do while.
		CREATE DEFINER=`root`@`localhost` PROCEDURE `Soma_Dias_Notas`(vDataInicial date, vDataFinal date)
		BEGIN
		  declare vDataAtual date;
		  declare vQtdNotas int;
		  declare vNotasDia int;
		  set vQtdNotas = 0;
		  set vDataAtual = vDataInicial;
		  while vDataAtual <= vDataFinal do
		    select count(*) into vNotasDia from notas_fiscais where DATA_VENDA = vDataAtual;
		    set vQtdNotas = vQtdNotas + vNotasDia;
		    select ADDDATE(vDataAtual, INTERVAL 1 DAY) into vDataAtual;
		  end while;
		  select vQtdNotas as Quantidade;
		END
		--
		CREATE PROCEDURE `Soma_Dias_Notas`()
		BEGIN
		  DECLARE DATAINICIAL DATE;
		  DECLARE DATAFINAL DATE;
		  DECLARE NUMNOTAS INT;
		  SET DATAINICIAL = '20170101';
		  SET DATAFINAL = '20170110';
		  WHILE DATAINICIAL <= DATAFINAL
		  DO
		    SELECT COUNT(*) INTO NUMNOTAS  FROM notas_fiscais WHERE DATA_VENDA = DATAINICIAL;
		    SELECT concat(DATE_FORMAT(DATAINICIAL, '%d/%m/%Y'), '-' , CAST(NUMNOTAS as CHAR(50)));
		    SELECT ADDDATE(DATAINICIAL, INTERVAL 1 DAY) INTO DATAINICIAL;
		  END WHILE;
		END
		-- Imprime a quantidade diária com o texto formatado.
		
  .Uso de CURSOR:
  	Cursor é uma estrutura do MySQL é uma variável que funciona como um array, onde podemos usar um select que retorne mais de uma linha e jogar esse resultado para o cursor, essa estrutura irá permitir uma interatividade linha a linha através de uma determinada ordem.
  	
  	Obs: Cursor pode guardar mais de uma coluna em sua estrutura interna.
  	
  	Obs: Ao utilizar o SELECT INTO, devemos garantir que o select retorne apenas uma linha, o mysql não tem a capacidade de converter automaticamente um array em uma variável. (Erro 1172)
  	
  	..Fases para o uso do CURSOR:
  		Declaração - É definido qual consulta SQL estará sendo carregada ao CURSOR.
  		Abertura - É aberto o CURSOR para percorrê-lo linha a linha.
  		Percorrimento - É percorrido linha a linha até o seu final.
  		Fechamento - Fecha o CURSOR.
  		Limpa - É limpado o CURSOR da memória.
  	
  	Ex: CREATE PROCEDURE `primeiro_cursor` ()
  	BEGIN
  	  declare vNome varchar(50);
  	  declare cNome cursor for select NOME from tabela_de_clientes limit 4;
  	  open cNome;
  	    fetch cNome into vNome; --lê a posição do cursor e registra na variável e passa a posição pro próximo
  	    select vNome;
  	    fetch cNome into vNome;
  	    select vNome;
  	    fetch cNome into vNome;
  	    select vNome;
  	    fetch cNome into vNome;
  	    select vNome;
  	  close cNome;
  	END
  	  
  	  ..Usando looping com cursor:
  	  	É preciso criar uma variável de controle para saber se o CURSOR ainda tem elementos, 0 ou 1, caso seja 0 o CURSOR não está no fim, caso seja 1 o CURSOR chegou ao fim. Assim teremos um error handler(for not found), para caso tente imprimir uma posição vazia do cursor, ele muda a variável pra 1.
  	  	
  	  	Obs: Usamos o handler para erro not found, porque quando damos um fetch em uma posição que não existe no cursor, o erro resultante é um not found.
  	  	
  	  	CREATE PROCEDURE `cursor_looping` ()
		BEGIN
		  declare vFimDoCursor int default 0;
		  declare vNome varchar(50);
		  declare cNome cursor for select NOME from tabela_de_clientes limit 4;
		  declare continue handler for not found set vFimDoCursor = 1;
		  open cNome;
		    while vFimDoCursor = 0 do
		      fetch cNome into vNome;
		      select vNome as Nome;
		    end while;
		  close cNome;
		END

  	  	Obs: Nesse caso o último nome é selecionado duas vezes, pois quando for acessar uma posição vazia do cursor, ele vai entrar no while vai tentar dar fetch e não vai conseguir, vai dar erro e vai chamar o handler, que vai mudar a variável pra 1, porém ainda no while ele continua selecionando o nome, a seguir terá a solução minha:
  	  		CREATE DEFINER=`root`@`localhost` PROCEDURE `cursor_looping_minha_solucao`()
			BEGIN
			  declare vFimDoCursor int default 0;
			  declare vNome varchar(50);
			  declare cNome cursor for select NOME from tabela_de_clientes limit 4;
			  declare continue handler for not found set vFimDoCursor = 1;
			  open cNome;
			    while vFimDoCursor = 0 do
			      fetch cNome into vNome;
			      if vFimDoCursor = 0 then select vNome as Nome;
			      end if;
			    end while;
			  close cNome;
			END
  	
  		Exercício: Crie uma Stored Procedure usando um cursor para achar o valor total de todos os créditos de todos os clientes. Chame esta SP de Limite_Creditos - (Fiz uma que imprime o valor de cada cliente e imprime também a soma total)
  			CREATE DEFINER=`root`@`localhost` PROCEDURE `Limite_Creditos`()
  			BEGIN
  			  declare vFimDoCursor int default 0;
  			  declare vLimiteCliente float;
  			  declare vLimiteTotal float;
  			  declare cLimite cursor for select LIMITE_DE_CREDITO from tabela_de_clientes;
  			  declare continue handler for not found set vFimDoCursor = 1;
  			  set vLimiteTotal = 0.0;
  			  open cLimite;
  			    while vFimDoCursor = 0 do
  			      fetch cLimite into vLimiteCliente;
  			      if vFimDoCursor = 0 then
  			        set vLimiteTotal = vLimiteTotal + vLimiteCliente;
  			        select vLimiteCliente as Limite;
  			      end if;
  			    end while;
  			  close cLimite;
  			  select vLimiteTotal as `Limite Total`;
			END
  		
  		Obs: O erro handler deve estar declarado depois da declaração do cursor.
  		
  	..Acessando vários campos com um cursor:
		Para poder receber vários campos de um registro é necessário criar uma variável pra cada campo.
		
		CREATE DEFINER=`root`@`localhost` PROCEDURE `cursor_looping_campos`()
		BEGIN
		  declare vFimDoCursor int default 0;
		  declare vCidade, vEstado, vCEP varchar(50);
		  declare vNome, vEndereco varchar(150);
		  declare cInfo cursor for select NOME, ENDERECO_1, CIDADE, ESTADO, CEP from tabela_de_clientes;
		  declare continue handler for not found set vFimDoCursor = 1;
		  open cInfo;
		    while vFimDoCursor = 0 do
		      fetch cInfo into vNome, vEndereco, vCidade, vEstado, vCEP;
		      if vFimDoCursor = 0 then 
		        select concat('Nome: ', vNome, ', Endereco: ', vEndereco, ', ', vCidade, '-', vEstado, ', CEP:', vCEP) as `Informação`;
		        select vNome as Nome, vEndereco as `Endereço`, vCidade as Cidade, vEstado as Estado, vCEP as CEP;
		      end if;
		    end while;
		  close cInfo;
		END
		
		
		Exercício:
			CREATE DEFINER=`root`@`localhost` PROCEDURE `faturamento_mes_ano`(vMes int, vAno year)
			BEGIN
			  declare vFimDoCursor int default 0;
			  declare vFaturamento float default 0;
			  declare vFaturamentoTotal float default 0;
			  declare cInfos cursor for select sum(A.QUANTIDADE * A.PRECO) as Faturamento from itens_notas_fiscais A
			    inner join notas_fiscais B on A.NUMERO = B.NUMERO
			    where month(B.DATA_VENDA) = vMes and year (B.DATA_VENDA) = vAno
			    group by Data_Venda;
			  declare continue handler for not found set vFimDoCursor = 1;
			  open cInfos;
			    while vFimDoCursor = 0 do
			      fetch cInfos into vFaturamento;
			      if vFimDoCursor = 0 then
			        set vFaturamentoTotal = vFaturamento + vFaturamentoTotal;
			      end if;
			    end while;
			  close cInfos;
			  select vMes as `Mês`, vAno as Ano, vFaturamentoTotal as Faturamento;
			END
			
			CREATE DEFINER=`root`@`localhost` PROCEDURE `faturamento_mes_ano_prof`()
			
		Obs: Na hora de fazer o FETCH as variáveis precisam estar na mesma ordem que o select na declaração do CURSOR.
		
  .FUNÇÃO: 
  	Diferente de sub-rotinas (STORED PROCEDURES) que são uma série de comandos padronizados para serem utilizados, mas que não tem como objetivo necessariamente retornar algo. Uma função são comandos que vão ser executados com o objetivo de retornar um valor, sendo ele por exemplo para ser usado dentro de uma sub-rotina.
  	
  	..Fórmula de uma função:
  		CREATE FUNCTION nome_funcao (parametros) RETURNS datatype;
  		BEGIN
  		DECLARE declaracao;
  		...
  		execucao
  		...
  		RETURN resultado;
  		...
  		END;
  		
  	..Criação de uma função:
  		Botão direito em Functions -> Create Function... -> Preencher com os comandos.
  	
  	..Exemplo de Função:
  		CREATE FUNCTION `f_acha_tipo_sabor` (vSabor varchar(50))
  		RETURNS varchar(20)
  		BEGIN
  		  declare vRetorno varchar(20) default ''; -- default palavra vazia
  		  case vSabor
  		    when 'Lima/Limão' then set vRetorno = 'Cítrico';
  		    when 'Laranja' then set vRetorno = 'Cítrico';
  		    when 'Morango/Limão' then set vRetorno = 'Cítrico';
  		    when 'Uva' then set vRetorno = 'Neutro';
  		    when 'Morango' then set vRetorno = 'Neutro';
  		    else set vRetorno = 'Ácido';
  		  end case;
  		  RETURN vRetorno;
  		END
  	
  	..Meios de chamar uma função: (usando a função do exemplo acima)
  		select f_acha_tipo_sabor ('Laranja');
  		select NOME_DO_PRODUTO, SABOR, f_acha_tipo_sabor (SABOR) as TIPO from tabela_de_produtos;
  		select NOME_DO_PRODUTO, SABOR from tabela_de_produtos where f_acha_tipo_sabor (SABOR) = 'Neutro';
  		
  	Obs: Da mesma forma que podemos usar o CONCAT em um select (Ex: select concat (NOME_DO_PRODUTO, ' ', SABOR) from tabela_de_produtos;) podemos usar uma função que criamos, ambas tem a mesma funcionalidade, porém uma é natural do sistema e outra foi criada por nós. 
  	
  	Obs: Normalmente o ambiente mysql não permite a criação de função, para isso mudar >
  		SET GLOBAL log_bin_trust_function_creators = 1;
